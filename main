-- your assignment:
--   make an app for your favourite type of animal or plant, like "birds" or "native Canadian prickly bushes"
--   your app's navigation bar must:
--     1. have a drop-down relevant to the topic, which opens a page on that topic, e.g., aquatic birds with a list of links
--     2. have two menu bar items which don't have to do anything
--     3. have a search field, which when non-empty causes a carousel with (creative-commons-licensed) images to be displayed, and underneath that an accordian made up of search results
--   you must have at least 10 species, which you should list above your share link and code in the avenue submission
--   Marks: 1% - working drop-down
--          1% - search field causes update
--          1% - search field updates properly (ie "b ern" give "Big Bird", "Bert", "Ernie", "ber" -> ["Bert"])
--          1% - carosel works and has the right content
--          1% - accordian appears and has the right content
--          maximum 4% (so you can make some mistakes)

       

import Bootstrap.Form.Input as Input 
import Html.Events as Events

--this appears at the top of the browser screen (or on the tab)
title : String
title = "Seasame Street Confidential"

blankLine = Grid.row [] --this is an empty row (to add blank space)
              [ Grid.col []
                  [ Html.h6[Spacing.my3][] --change spacing number to make empty row bigger or smaller (0-5)
                  ]
              ]
        
page : Model -> List (Html Msg)
page model =
    [ Grid.container [] -- Wrap in a container to center the navbar
        [ Navbar.config NavbarMsg
            |> Navbar.withAnimation
            |> Navbar.collapseMedium            -- Collapse menu at the medium breakpoint
            |> Navbar.info                      -- Customize coloring
            |> Navbar.brand                     -- Add logo to your brand with a little styling to align nicely
                [ href "#" ]
                [ Html.img
                    [ src "https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Sesame_Street_logo.svg/1024px-Sesame_Street_logo.svg.png"
                    , class "d-inline-block align-top"
                    , style  "width" "120px" 
                    ]
                    []
                ]
            |> Navbar.items
                [ Navbar.itemLink
                    [ href "#" ] [ Html.text "Seasame Street Confidential" ]
                , Navbar.dropdown        
                    { id = "mydropdown"
                    , toggle = Navbar.dropdownToggle [] [ Html.text "Seasons" ]
                    , items =
                        List.map  ( \ year -> Navbar.dropdownItem
                                      [ href "#" ]
                                      [ String.fromInt year |> Html.text ]
                                  )
                               ( List.range 1969 2021 )
                    }
                ]
            |> Navbar.customItems
                [ Navbar.formItem []
                    [ Input.text [ Input.attrs [placeholder "character search", value model.searchString, Events.onInput UpdateSearch ]]
                    ]
                ]
            |> Navbar.view model.navbarState
        ]
     --HEADER
    , Html.text model.searchString
    , Html.div [] []
    ] 
    ++
    ( List.map (\ wrd -> Html.text (wrd ++ ", ")) model.searchList )

{- The number of accordions, carousels and pop ups.
   To add more than one of each, you must increase these numbers and then make sure to
   put the correct id in the code where you add it. The ids start at 0 and go up from there
   (0, 1, 2, 3, etc.)
-}
numAccordions = 1
numCarousels = 2
numPopUps = 1


type alias Model =
    { navKey : Navigation.Key
    , page : Page
    , time : Float
    , navbarState : Navbar.State
    , accordionStates : Dict Int Accordion.State --ADD ACCORDION
    , carouselStates : Dict Int Carousel.State -- ADD CAROUSEL
    , modalVisibilities : Dict Int Modal.Visibility -- ADD MODAL
    , searchString : String
    , searchList : List String
    }

type Page
    = Home
    | NotFound


type Msg
    = UrlChange Url
    | ClickedLink UrlRequest
    | NavbarMsg Navbar.State
    | NoOp
    | AccordionMsg Int Accordion.State --ADD ACCORDION
    | CarouselMsg Int Carousel.Msg --ADD CAROUSEL
    | CloseModal Int
    | ShowModal Int
    | Tick Float
    | UpdateSearch String

init : Flags -> Url -> Navigation.Key -> ( Model, Cmd Msg )
init flags url key =
    let
        ( navbarState, navCmd ) =
            Navbar.initialState NavbarMsg

        ( model, urlCmd ) =
            urlUpdate url { navKey = key
                          , navbarState = navbarState
                          , page = Home
                          , time = 0
                          , accordionStates = Dict.fromList <| List.map (\n -> (n,Accordion.initialStateCardOpen "")) (List.range 0 (numAccordions-1)) --ADD ACCORDION - what does accordion look like when you open the page?
                            --Accordion.initialStateCardOpen "card1" -- if you put a card id, the accordion starts with that card open
                          , carouselStates = Dict.fromList <| List.map (\n -> (n,Carousel.initialState)) (List.range 0 (numCarousels-1))
                          , modalVisibilities = Dict.fromList <| List.map (\n -> (n,Modal.hidden)) (List.range 0 (numPopUps-1))
                          , searchString = ""
                          , searchList = []
                          }
    in
        ( model, Cmd.batch [ urlCmd, navCmd ] )



subscriptions : Model -> Sub Msg
subscriptions model =
    --ADD ACCORDION - now that there are multiple subscriptions, they need to be grouped in Sub.batch
    Sub.batch [Navbar.subscriptions model.navbarState NavbarMsg
              , Sub.batch <| List.map (\(n, s) -> Accordion.subscriptions s (AccordionMsg n)) <| Dict.toList model.accordionStates
              , Sub.batch <| List.map (\(n, s) -> Carousel.subscriptions s (CarouselMsg n)) <| Dict.toList model.carouselStates
              , onAnimationFrame ( \ posix -> Tick ((Time.posixToMillis posix |> toFloat) * 0.001) )
              ]


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        ClickedLink req ->
             case req of
                 Browser.Internal url ->
                     ( model, Navigation.pushUrl model.navKey <| Url.toString url )

                 Browser.External href ->
                     ( model, Navigation.load href )


        UrlChange url ->
            urlUpdate url model

        NavbarMsg state ->
            ( { model | navbarState = state }
            , Cmd.none
            )

        NoOp -> (model, Cmd.none)

        --ADD ACCORDION
        AccordionMsg id state ->
            ( { model | accordionStates = Dict.insert id state model.accordionStates }
            , Cmd.none
            )

        --ADD CAROUSEL
        CarouselMsg id cMsg ->
            ( {model | carouselStates = Dict.update id
                                            (\m -> case m of
                                                    Just s -> Just <| Carousel.update cMsg s
                                                    Nothing -> Nothing
                                            ) model.carouselStates

             }
            , Cmd.none
            )

        --ADD MODAL
        CloseModal id ->
            ( { model | modalVisibilities = Dict.insert id Modal.hidden model.modalVisibilities } , Cmd.none )

        ShowModal id ->
            ( { model | modalVisibilities = Dict.insert id Modal.shown model.modalVisibilities } , Cmd.none )

        Tick t -> ({ model | time = t }, Cmd.none)
        
        UpdateSearch str ->
                        let searchString = String.filter filterChars str
                            listWords = (String.split " " (String.toLower searchString))
                            firstList = List.take ((List.length listWords)-1) listWords
                            lastList = List.drop ((List.length listWords)-1) listWords
                            searchList = (List.filter commonWrds firstList)++lastList --filter out common words only from fully typed keyword
                        in
                        ({ model | searchString = searchString
                                 , searchList = searchList
                                --, searching = True
                                --, searchBeginT = if model.searching then model.searchBeginT else model.t
                                --, searchContinuesT = model.t
                                --, menuState = Closed
                        }, Cmd.none )

filterChars char = if Char.isLower char || Char.isUpper char || Char.isDigit char || char == ' ' then True else False

commonWrds wrd = case wrd of
                  "the" -> False
                  "best" -> False
                  "with" -> False
                  "about" -> False
                  "and" -> False
                  "as" -> False
                  "at" -> False
                  "a" -> False
                  "to" -> False
                  "in" -> False
                  "by" -> False
                  "on" -> False
                  "for" -> False
                  "from" -> False
                  "greatest" -> False
                  "ever" -> False
                  "school" -> False
                  "grade" -> False
                  "catholic" -> False
                  "public" -> False
                  "junior" -> False
                  "senior" -> False
                  "elementary" -> False
                  "secondary" -> False
                  "district" -> False
                  "" -> False
                  _ -> True

resetViewport : Cmd Msg
resetViewport =
  Task.perform (\_ -> NoOp) (Dom.setViewport 0 0)


urlUpdate : Url -> Model -> ( Model, Cmd Msg )
urlUpdate url model =
    case decode url of
        Nothing ->
            ( { model | page = NotFound }, resetViewport )

        Just route ->
            ( { model | page = route }, resetViewport )

decode : Url -> Maybe Page
decode url =
    { url | path = Maybe.withDefault "" url.fragment, fragment = Nothing }
    |> UrlParser.parse routeParser

routeParser : Parser (Page -> a) a
routeParser =
    UrlParser.oneOf
        [ UrlParser.map Home top
        ]


view : Model -> Browser.Document Msg
view model =
    { title = case model.page of
          Home ->
            title

          NotFound ->
              "Page Not Found"
    , body =
        [
          Html.node "link" [attribute "rel" "stylesheet", href "https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"] []
        , Html.node "link" [attribute "rel" "stylesheet", href "https://documents.mcmaster.ca/www/cdn/css/1.0/mcm-bw.css"] []
        ,  Html.div []
            [ mainContent model
            ]
        ]
    }

mainContent : Model -> Html Msg
mainContent model =
    Grid.container [] <|
        case model.page of
            Home ->
                page model

            NotFound ->
                pageNotFound


pageNotFound : List (Html Msg)
pageNotFound =
    [ Html.h1 [Spacing.my4] [ Html.text "Not found" ]
    , Html.text "Sorry, couldn't find that page"
    ]



